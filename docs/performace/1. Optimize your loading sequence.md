# 1. Optimize your loading sequence

- 중요한 컴포넌트와 리소스가 적절한 시간에 사용가능할 때 사용자들은 해당 어플리케이션이 완벽하다고 느낄 수 있다. 좋은 사용자 경험은 Core Web Vital 지수와도 관련이 있다.

### Vital 지표

- **First Contentful Paint(FCP)**: 페이지가 로드될 때 브라우저가 DOM 콘텐츠의 첫 번째 부분을 렌더링하는 데 걸리는 시간에 관한 지표
- **Speed Index(SI)**: 페이지 로드 중에 콘텐츠가 시각적으로 표시되는 속도를 나타내는 지표, 콘텐츠의 일부라도 먼저 떴다면 더 높은 점수를 가짐
- **Time to Interactive(TTI)**: 사용자가 페이지와 상호 작용이 가능한 시점까지 걸리는 시간을 측정한 지표
- **Total Blocking Time(TBT)**: 페이지가 클릭, 키보드 입력 등의 사용자 입력에 응답하지 않도록 차단된 시간을 종합한 지표, 측정은 FCP와 TTI 사이의 시간 동안 이루어짐, 메인 스레드를 독점하여 다른 동작을 방해하는 작업에 걸린 시간을 총합
- **Cumulative Layout Shift(CLS)**: 페이지 로드 과정에서 발생하는 예기치 못한 레이아웃 이동을 측정한 지표

## 왜 로딩시간을 최적화하는 것이 어려운가?

- 개발자들이 예상하는 것과 브라우저가 리소스의 우선순위를 지정하는 데에서 차이가 발생

### Sub-optimal sequencing

- Web Vital의 각 지표들의 의미를 이해하고 또 어떤 순서로 발생하는지를 알아야 한다.
- FCP → LCP → FID

### Network/CPU Utilization

- 리소스가 적절하게 파이프라인화되지 않아 CPU와 네트워크 활용을 잘 보장하지 못할 수 있다. 프로세스가 네트워크에 바운드되어 있거나 네트워크가 프로세스에 바운드되어 있을 경우 CPU에서 “Dead Time”이 발생한다. (CPU가 비효율적으로 사용되는 시간을 의미)
- 스크립트를 한번에 많이 다운로드하는 것보다 스크립트 크기를 쪼개서 순차적으로 다운로드 받을 때 CPU와 네트워크 대역폭을 잘 활용할 수 있다.

### Third-Party(3P) Products

- 3P 내에 광고, 애널리틱스, 소셜 위젯, 라이브챗 등을 위해 웹사이트에서 사용되는데 각 3P는 각자만의 자바스크립트 파일, 이미지, 폰트 등을 가지고 있다.
- 일반적으로 3P는 3P를 사용하는 클라이언트 사이트의 로딩 성능을 최적화할 동기가 부족하다. 인터랙션을 방해하는 무거운 코드를 가지거나 다른 중요한 리소스 다운로드를 방해하기도 한다. 성능 대신 기능에 더 초점을 맞추고 있을 확률이 높다. 이로 인해 리소스를 효과적으로 핸들링하고 순서를 보장하는 것이 어렵게 된다.

### Platform Quirks(특이점)

- 브라우저마다 request에 대한 우선순위를 지저하고 힌트를 구현하는 방식에 차이가 있을 수 있다. 특정 브라우저에서만 해당되는 동작은 로딩 순서를 일관되게 보장하기가 어렵다.
- 예시) Chromium의 preload 버그 > 브라우저에게 핵심 리소스를 가능한 빨리 다운로드하도록 지시하는 것

### HTTP/2 Prioritization

- HTTP/2 프로토콜 자체는 리소스의 순서나 우선순위에 대한 옵션이나 설정을 제공하지 않는다.
- 서버나 CDN이 각 리소스에 대한 req의 우선순위를 어떻게 지정할 것인지 예측할 수 없다.

### Resource Level Optimization

- 효과적인 순서를 만들기 위해서 중요한 CSS는 인라인으로, 이미지는 올바른 크기로, 자바스크립트는 적절히 스플릿되어 점진적으로 전달되어야 한다.
- React의 Suspense, Concurrent mode, data fetching 등은 실험적인 기능이며 dynamic import는 직관적이지 않고 개발자가 직접 수동으로 식별해야 한다.
- code split을 할 때는 각 라우트와 인터랙션에서 필요한 JS를 최소화하면서 브라우저 성능에 악영향을 미지 않는 정도의 밸런스를 찾아야 한다. (right granularity) 일반적인 deps의 캐싱을 허용해야 한다.
- 죽은 코드 또는 사용하지 않는 코드, 오래된 코드는 성능에 부정적인 영향을 끼친다. 라이브러리와 패키지가 ES 모듈 형태로 퍼블리싱되지 않아 번들러의 트리셰이킹과 최적화를 방해한다.

## 각 리소스별 최적화

### Critical CSS

- FCP에 필요한 최소한의 CSS를 의미하며 다른 CSS 파일에서 가져오는 것보다 HTML 내에서 인라인으로 포함시키는 것이 좋다. 현재 라우트에 필요한 CSS만을 다운로드한다.
- 인라인 처리가 불가능한 경우에는 preload한다. 해당 CSS는 여러 도메인에서 제공하거나 서드파티 critical css를 직접 사용하는 것은 지양하고 자체 서버를 사용하여 proxy로 제공할 수 있도록 해야 한다.
- CSS를 가져오는 데 지연이 발생하거나 순서가 꼬이는 경우에는 FCP와 LCP에 좋지 않다. 인라인 CSS가 너무 길어지면 파싱 시간이 길어져 FCP에 좋지 않으며 크리티컬한 것과 아닌 것을 구분해야 한다.
- 인라인 CSS는 캐싱되지 않으므로 이에 대한 중복 리퀘스트를 날리는 방법도 있다. 하지만 이 방법으로 FID에 영향이 갈 수도 있따.

### Fonts

- 크리티컬 폰트도 CSS처럼 인라인으로 처리되어야 한다. 인라인 처리가 불가능한 경우에 preconnect가 지정된 상태에서 로드되어야 한다. 폰트를 로드하는데 지연이 발생하는 경우 FCP에 영향이 간다.
- 폰트를 인라인으로 처리하는 것은 HTML을 크게 만들고 다른 크리티컬한 리소스를 가져오는 것을 느리게 만들 수도 있으므로 폰트 fallback을 사용하여 텍스트를 보여주는 것이 좋다. 하지만 fallback을 사용하면 CLS에 영향을 미치기도 하며 실제 폰트가 로드되었을 때 스타일링과 레이아웃 작업이 발생하여 FID 지표에 좋지 않을 수 있다.

### ABT 이미지(화면 상단에 있는 이미지)

- 뷰포트 내에 있으므로 페이지 로드 시 사용자에게 처음으로 보여지는 이미지로 모든 ABT 이미지는 크기가 지정되어야 한다. 크기가 지정되지 않으면 레이아웃 변경사항이 발생하므로 CLS 지표에 영향을 미친다.
- placeholder 사이즈가 실제 사이즈와 일치되지 않으면 LCP가 다시 트리거 된다.

### BTF 이미지(화면 하단에 있는 이미지)

- 사용자에게 즉시 보여지지 않는 이미지로 지연 로딩을 하기 좋은 후보가 된다. BTF 이미지가 다른 중요한 리소스보다 먼저 로딩되지 않도록 해야 한다.

### 1P JS

- 어플리케이션의 인터랙션 가능 여부에 영향을 미친다. 네트워크에서 ABT 이미지보다 먼저 로드되어야 하고, 주 스레드에서 3P JS보다 먼저 실행되어야 한다. 1P JS는 서버에서 렌더링된 페이지에서 FCP와 LCP를 차단하지 않는다.

### 3P JS

- 3P sync 스크립트는 CSS 및 폰트의 파싱을 차단하여 FCP도 차단할 수 있다. 3P 스크립트를 로드할 때는 효과적으로 제어할 수 있도록 관리가 필요하다.
- “너무 적게 너무 늦게” “너무 많이 너무 빨리” 사이에서 균형 찾기

![Untitled](https://ia802209.us.archive.org/BookReader/BookReaderImages.php?zip=/4/items/learning-patterns/learning-patterns-final-v1.1_jp2.zip&file=learning-patterns-final-v1.1_jp2/learning-patterns-final-v1.1_0334.jp2&id=learning-patterns&scale=4&rotate=0)

### 요약

- 크리티컬한 CSS와 폰트는 가장 높은 우선순위로 처리되어야 한다.
- 스크립트는 HTML 문서 내 위치 및 async, defer 또는 block 여부에 따라 다른 우선순위를 받는다.
- 첫 번째 이미지 이전에 요청된 blocked 스크립트는 이미지를 가져온 이후에 요청된 다른 스크립트보다 더 높은 우선순위를 가진다.
- async, defer 또는 inject된 스크립트는 문서 내 위치와 관계없이 가장 낮은 우선순위를 가진다.
- 뷰포트 내에 있는 이미지는 없는 이미지보다 높은 우선순위를 가진다.

## 이상적인 로딩 순서

- Next.js를 사용한다면 전용 ScriptLoader 컴포넌트를 사용하는 것이 좋다. 해당 컴포넌트는 “크리티컬 렌더링 경로를 최적화하고 외부 스크립트가 페이지 로드를 방해하지 않도록” 설계되었다.
- 하이드레이션 이전/이후에 목적에 맞게 3P 스크립트를 로드한다.

### 3P를 사용하지 않는 경우

| 메인 브라우저 스레드
이벤트 순서 |  | 네트워크 요청 순서 |  |
| --- | --- | --- | --- |
| 1 | HTML 파싱 | 작은 인라인 1P 스크립트 | 1 |
| 2 | 작은 인라인 1P 스크립트 실행 | 인라인된 크리티컬 CSS (외부출처인 경우 preload) | 2 |
|  |  | 인라인된 크리티컬 폰트 (preconnect) | 3 |
| 3 | FCP 리소스 파싱 | LCP 이미지 (preconnect) | 4 |
| FCP |  | (인라인 font-css에서 트리거된) 폰트 | 5 |
| 4 | LCP 리소스 렌더링 | 크리티컬하지 않은 (비동기) CSS | 6 |
|  |  | 인터랙션을 위한 1P JS | 7 |
|  |  | ABT 이미지 (preconnect) | 8 |
| LCP |  | BTF 이미지 | 9 |
| 5 | ABT 이미지 렌더링 |  |  |
| visually complete |  |  |  |
| 6 | 논크리티컬 CSS 파싱 |  |  |
| 7 | 1P JS 실행 및 하이드레이션 | JS 청크 지연로딩 | 10 |
| FID |  |  |  |
1. 순서를 수동으로 관리해야 하는 `preload` 는 지양하는 것을 권장한다. 특히 크리티컬 폰트에서!
2. 폰트와 CSS는 인라인으로 처리되는 것이 이상적이다. 다른 곳에서 오는 폰트는 `preconnect` 를 사용하여 가져온다.
3. 다른 출처의 모든 리소스에 대한 사전 연결을 보장하기 위해 해당 리소스에 대해 `preconnect` 를 권장한다.
4. 크리티컬하지 않은 CSS는 사용자 인터랙션이 시작되기 전에 가져온다. (FID)
5. JS를 다운로드하고 파싱하는 데 시간이 걸리므로, ABT 이미지를 가져오기 전에 1P JS를 먼저 가져온다.
6. 1P JS를 파싱하는 동안 주 스레드에서 HTML 파싱과 ABT 이미지를 다운로드는 병렬로 계속 진행될 수 있다.

### 3P를 사용하는 경우

| 메인 브라우저 스레드
이벤트 순서 |  | 네트워크 요청 순서 |  |
| --- | --- | --- | --- |
| 1 | HTML 파싱 | 3P 리소스를 차단하는 FCP | 1 |
|  |  | 작은 인라인 1P 스크립트 | 2 |
| 2 | 작은 인라인 1P 스크립트 실행 | 인라인된 크리티컬 CSS (외부출처인 경우 preload) | 3 |
| 3 | 3P 리소스를 차단하는 FCP 리소스 파싱 | 인라인된 크리티컬 폰트 (preconnect) | 4 |
| 4 | FCP 리소스 파싱 | LCP에 필요한 ABT 이미지에 대한 3P | 5 |
| FCP |  | LCP 이미지 (preconnect) | 6 |
| 5 | LCP에 필요한 이미지에 대한 3P 렌더링 | (인라인 font-css에서 트리거된) 폰트 | 7 |
| 6 | LCP 리소스 렌더링 | 크리티컬하지 않은 (비동기) CSS | 9 |
|  |  | 인터랙션을 위한 1P JS | 10 |
| LCP |  | ABT 이미지 (preconnect) | 11 |
| 7 | ABT 이미지 렌더링 | 기본 3P JS | 12 |
| 8 | 논크리티컬 CSS 파싱 |  |  |
| 9 | 첫 유저 인터랙션에 필요한 경우 3P 실행 | BTF 이미지 | 13 |
| 10 | 1P JS 실행 및 하이드레이션 | JS 청크 지연로딩 | 14 |
| FID |  | 덜 중요한 3P JS | 15 |